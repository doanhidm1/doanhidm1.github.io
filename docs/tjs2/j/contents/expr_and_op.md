# 式と演算子

式は、演算子とオペランドの集まり、あるいは即値です。

　通常、スクリプト中に以下のように記述することができます。

`式;`
　このように式の後にセミコロンをつけると、その式がその場で評価( = 実行 )され、その式としての結果は捨てられます。

`例:
    a = b;
    // 演算子 = の動作によって、a 変数に 変数b が代入される

    func();
    // 演算子 ( ) の動作によって、func が関数として呼び出されるが、関数の戻り値
    // は捨てられる

    1 + 3;
    // + 演算子の動作によって、1 と 3 が加算されるが、結果は捨てられる(実際はこ
    // の式は意味を持たないので実行すらされない)`

# 真と偽

いくつかの演算子は、真か偽 (論理値) を扱います。演算の結果が 0 の場合は偽、0 以外の場合は 真になります。
　文字列に対して真偽が問われた場合は、空文字列の場合は偽、それ以外の場合は数値に変換しようとして成功すれば、その数値としての結果が真偽になり、失敗すれば偽になります。

# 演算子

以下、演算子を優先順位の低いものから順に説明していきます。

# if 演算子

if 演算子 `if` は、右側にあるものを評価した結果が真の場合のみに、左側にあるものを評価する演算子です。

`例:
    a=b if b!=0; // b が 0 でなければ a に b を代入`

　演算子の結果を得ることはできません。

# 順次演算子

順次演算子 `,` (カンマ) は、左にあるものを評価して、つぎに右側にあるものを評価します。それ以外の事は行いません。演算子全体としては、右側にあるものを評価した結果になります。カンマが続けて複数書かれた場合は、左側にあるものから順に評価されます。

`例:
    c = (a=1, b=2); // a=1, b=2 が評価され、c には 2 が代入される
    a=1, b=2, c=3; // a=1, b=2, c=3 の順に評価される`

# 代入演算子

代入演算子には以下のものがあります。

`= <-> &= |= ^= -= += %= /= \= *= ||= &&= >>= <<= >>>=`
　このうち、 = 演算子は単純代入演算子で、右側のものを評価した結果を左側のものに代入するという動作をし、演算子全体の値としては右側にあるものを評価した結果となります。

`例:
    a = 0;  // a に 0 を代入
    a = b = c = 0; // c , b, a の順に 0 を代入`

　`<->` 演算子はいれかえを行います。まず、左側のものを評価し、次に右側のものを評価します。そのあと、右側を評価した結果を左側に代入し、左側を評価した結果を右側に代入します。演算子の結果を得ることはできません。
　現時点では左右の式はそれぞれ、式の値を得るためと式に代入するために*２回評価されます*。将来的にこの仕様は変更される可能性があるので、評価回数に依存した記述をしないようにしてください。

　それ以外の演算子は、すべて、`演算子=` の形式をとっており、`A 演算子= B` と記述された場合は、`A = A 演算子 B` という意味になります。演算子全体の値としては、演算の結果の値となります。

# 条件演算子

条件演算子 `? :` は３項演算子です。`A ? B : C` の形式で書くと、A を評価し、真だった場合に B を評価し、C を無視します。偽だった場合は C を評価し、B を無視します。演算子全体の値としては、B または C の評価された方の値になります。

　条件演算子は左辺値として使うことができます。

`例:
    a = b==0 ? c : b; // b が 0 だったら a に c を、 b が 0 でなかったら a に b を代入
    b==0 ? (a=c) : (a=b); // 上と同じ意味
    (a ? b : c ) = d; // a が真ならば b に、a が偽ならば c に、 d を代入 (左辺値として使用した例)`

# 論理 OR 演算子

論理 OR 演算子 `||` は、左側にあるものをまず評価し、真ならば右側にあるものを無視して、演算子全体の結果としては真になります。左側にあるものを評価した結果が偽だった場合、右側にあるものを評価し、その真偽の結果が演算子全体の結果となります。

# 論理 AND 演算子

論理 AND 演算子 `&&` は、左側にあるものをまず評価し、偽ならば右側にあるものを無視して、演算子全体の結果としては偽になります。左側にあるものを評価した結果が真だった場合、右側にあるものを評価し、その結果が演算子全体の結果となります。

# ビット OR 演算子

ビット OR 演算子 `|` は、ビットごとの論理 OR をとります。左側にあるもの、右側にあるものの順に評価し、その結果を整数として、ビットごとの OR をとったものが演算子全体の値となります。

# ビット XOR 演算子

ビット XOR 演算子 `^` は、ビットごとの論理 XOR をとります。左側にあるもの、右側にあるものの順に評価し、その結果を整数として、ビットごとの XOR をとったものが演算子全体の値となります。

# ビット AND 演算子

ビット AND 演算子 `&` は、ビットごとの論理 AND をとります。左側にあるもの、右側にあるものの順に評価し、その結果を整数として、ビットごとの AND をとったものが演算子全体の値となります。

# 同定演算子

`== != === !==`は同定演算子の類です。

`==` 演算子
:   `==` 演算子は、左側にあるものを先に評価し、次に右側にあるものを評価します。両者が一致すれば演算子全体で真、一致しなければ演算子全体で偽になります。両辺の演算の結果、型が異なれば適切に変換されてから比較されます。たとえば、`-1 == '-1'` は真になります。

`!=` 演算子
:   `!=` 演算子は、`==` 演算子の真偽が逆になったものです。

`===` 演算子
:   `===` 演算子は識別比較演算子と呼ばれ、`==` 演算子と同じですが、型の変換は行われず、型までもが一致しなければ真になりません。

`!==` 演算子
:   `!==` 演算子は、`===` 演算子の真偽が逆になったものです。

# 比較演算子

`< > <= >=` は比較演算子の類です。

`<` 演算子
:   `<` 演算子は、左側にあるものを先に評価し、右側にあるものを次に評価します。左側を評価した結果が右側を評価した結果よりも小さければ真になり、そうでなければ偽になります。

`>` 演算子
:   `>` 演算子は、左側にあるものを先に評価し、右側にあるものを次に評価します。右側を評価した結果が左側を評価した結果よりも小さければ真になり、そうでなければ偽になります。

`<=` 演算子
:   `<=` 演算子は、左側にあるものを先に評価し、右側にあるものを次に評価します。左側を評価した結果が右側を評価した結果よりも小さいか等しいならば真になり、そうでなければ偽になります。

`>=` 演算子
:   `>=` 演算子は、左側にあるものを先に評価し、右側にあるものを次に評価します。右側を評価した結果が左側を評価した結果よりも小さいか等しいならば真になり、そうでなければ偽になります。

　比較するものが両方とも文字列の場合は、ワイド文字コード順(通常はUNICODE)での比較になります。

# ビットシフト演算子

`>> << >>>`はビットシフト演算子の類です。

`>>` 演算子
:   `>>` 演算子は、まず左側にあるものを評価し、右側にあるものを次に評価します。左側の結果を整数として、右側の結果の回数分だけ右に符号付きビットシフトしたものが演算子全体の結果となります。

`<<` 演算子
:   `<<` 演算子は、まず左側にあるものを評価し、右側にあるものを次に評価します。左側の結果を整数として、右側の結果の回数分だけ左にビットシフトしたものが演算子全体の結果となります。

`>>>` 演算子
:   `>>>` 演算子は、`>>`演算子と同じですが、左側を評価した結果を符号無し整数として扱います。

# 加減算演算子

`+ -` は、それぞれ加算演算子と減算演算子です。

`+` 演算子
:   `+` 演算子は、先に左側を評価し、次に右側を評価します。結果が両方とも数値だった場合は、数値としての加算が行われ、演算子全体の結果となります。どちらか、あるいは両方が文字列だった場合は、文字列としての加算が行われ、演算子全体としては 左側の結果の後ろに右側の結果を結合した文字列になります。数値は文字列に、オブジェクト型は文字列に変換できれば変換されます。

`-` 演算子
:   `-` 演算子は、先に左側を評価し、次に右側を評価します。その後、数値として左側の結果から右側の結果が引かれ、それが演算子全体の値となります。

# 乗除余算演算子

`% / \ *` は、それぞれ剰余算、除算、整数除算、乗算演算子です。

`%` 演算子
:   `%` 演算子は、先に左側を評価し、次に右側を評価します。そのあと、左側を右側で割った剰りが演算子全体の値になります。値は両方とも整数として扱われます。

`/` 演算子
:   `/` 演算子は、先に左側を評価し、次に右側を評価します。そのあと、左側を右側で割った値が演算子全体の値になります。値は実数として扱われます。

`\` 演算子
:   `\` 演算子は、/ 演算子のように除算を行いますが、値は整数として扱われます。

`*` 演算子
:   `*` 演算子は、先に左側を評価し、次に右側を評価します。そのあと、左側を右側で掛けた値が演算子全体の値になります。値は実数として扱われます。

# 一般的な単項演算子の類

以下はすべて単項演算子です ( `instanceof` は例外 )。

`!` 演算子
:   前置の `!` 演算子は、論理否定演算子です。右側にあるものを評価したものの真偽を逆にしたものが演算子全体の値となります。

`~` 演算子
:   `~` 演算子は、ビット否定演算子です。右側にあるものを評価したものを整数とし、ビットごとの否定 ( 1→0、0→1 ) を行ったものが演算子全体の値となります。

`--` 演算子
:   前置の `--` 演算子は、前置デクリメント演算子です。右側にあるものから１を減じ、減じた後の値が演算子全体の値となります。

`++` 演算子
:   前置の `++` 演算子は、前置インクリメント演算子です。右側にあるものに１を加算し、加算した後の値が演算子全体の値となります。

`new` 演算子
:   `new` 演算子は、右側にある関数評価式を関数呼び出しではなくオブジェクトの作成を行わせるようにします。

`invalidate 演算子`
:   `invalidate` 演算子は、右側にあるものを評価し、その結果のオブジェクトを無効化します。右側にある物が void, 文字列, 数値, オクテット列だった場合は何もしません。オブジェクトがすでに無効化されていた場合も何もしません。null が指定された場合は例外が発生します。

`isvalid 演算子`
:   `isvalid` 演算子は、右側、あるいは左側にあるものを評価し、その結果のオブジェクトが有効な場合に true、 無効な場合に false になります。演算子を評価対象の前に置いても、後ろに置いても同じ意味になります。対象が void, 文字列, 数値, オクテット列だった場合は常に真を返します。null が指定された場合は例外が発生します。

`delete 演算子`
:   `delete` 演算子は、右側に書いたオブジェクトのメンバ、あるいはローカル変数を消去します。消去に成功すれば true、失敗すれば false になります。

`typeof 演算子`
:   `typeof` 演算子は、右側にあるものを評価し、その型によって以下の文字列となります : void:"void"、整数:"Integer"、実数:"Real"、オブジェクト:"Object"、文字列:"String"、オクテット列:"Octet" 。ただし、オブジェクトのメンバを指定した場合で、メンバが無かった場合は "undefined" になります。

`# 演算子`
:   `#` 演算子は、右側にあるものを評価し、文字列として最初の一文字の文字コードを演算子全体の値とします。

`$ 演算子`
:   `$` 演算子は、右側にあるものを評価し、その結果を文字コードとして、それが表す文字一文字を演算子全体の値とします。

`+ 演算子`
:   単項の `+` 演算子は、右側にあるものを評価します。右側にあるものが実数や整数ならば何もしません。それ以外の場合は、実数や数値への変換を試み、その結果が演算子全体の結果となります。文字列を数値に変換しようとする場合は、変換に失敗した場合は、例外を発生せず、 0 になります。小数点を含むような実数表現であれば実数に、そうでなければ整数に変換されます。文字列の先頭に 0x や 0b 、0 があれば、それぞれ 16 進数、2 進数、8 進数として解釈されます。

`- 演算子`
:   単項の `-` 演算子は、左側にあるものを評価し、その結果を数値として、正負を逆にしたものを演算子全体の結果とします。

`& 演算子`
:   単項の `&` 演算子は、右側に書いたオブジェクトのメンバへのアクセスを、プロパティハンドラを介さない、プロパティオブジェクトそのものへのアクセスに変更します。たとえば、propobj = &obj.prop; では、obj のメンバプロパティ prop のプロパティハンドラは起動されず、メンバプロパティ prop のプロパティオブジェクトそのものへの参照が propobj に代入されます。右側がプロパティへのアクセスではなかった場合の動作は不定です。

`* 演算子`
:   単項の `*` 演算子は、右側に書いたオブジェクトのプロパティハンドラを動作させます。右側にはプロパティオブジェクトを表す式を書かなければなりません。たとえば、\*propobj = 1; は、プロパティオブジェクトである propobj の setter ハンドラを呼び出し、1 を代入します。

`instanceof 演算子`
:   `instanceof` 演算子は、左側にあるものを評価し、次に右側にあるものを評価します。右側にはクラス名となる、文字列になるものを書き、左側にあるものが、そのクラスのインスタンスであれば true、そうでなければ false になります。

# 関数呼び出し、カッコ類、後置インクリメント・デクリメントなど

`( ) 演算子`
:   `( )` 演算子は、演算の優先順位を変更します。または、関数呼び出しを行います。

`[ ] 演算子`
:   `[ ]` 演算子は、間接メンバ選択演算子です。`A [ B ]` と書かれた場合、A を先に評価し、 B を次に評価します。B を文字列として、そのメンバ名を A から探し、演算子全体としてはそのメンバへのアクセスとなります。左辺値として使われた場合は、オブジェクト内にメンバ B を、もし無ければ新規に作成する、という作用も伴います。

`. 演算子`
:   `.` 演算子は、直接メンバ選択演算子です。`A.B` と書かれた場合、A を評価します。B を A から探し、演算子全体としてはそのメンバへのアクセスとなります。左辺値として使われた場合は、オブジェクト内にメンバ B を、もし無ければ新規に作成する、という作用も伴います。
    もし `.` 演算子の左側が省略された場合は、with ステートメントの外側ならば global オブジェクト内のメンバを、with ステートメントの内側ならばその with で示されたオブジェクトのメンバを参照します。

`++ 演算子`
:   後置の `++` 演算子は、後置インクリメント演算子です。左にあるものに１を加算し、演算子全体としては加算する前の、左にあるもの、になります。

`-- 演算子`
:   後置の `--` 演算子は、後置デクリメント演算子です。左にあるものから１を減じ、演算子全体としては減じる前の、左にあるもの、になります。

`! 演算子`
:   後置の `!` 演算子は、式評価演算子です。左にあるものを評価した結果を文字列として、それを式文字列として解釈します。結果は、その式文字列を解釈して評価した結果になります。式は this コンテキスト (この演算子を使った位置での this) 上で動作します。

`incontextof 演算子`
:   `incontextof` 演算子は、左にあるものを先に評価し、次に右にあるものを評価します。左にあるものを評価した結果をオブジェクトとして、そのオブジェクトのコンテキスト部分を、右にあるものを評価した結果と置き換えたものが演算全体の結果となります。

`int 演算子`
:   int 演算子は、右にあるものを評価し、それを整数型に変換したものが演算子全体の結果となります。C 言語のキャスト風に、(int) と書くこともできます。

`real 演算子`
:   real 演算子は、右にあるものを評価し、それを実数型に変換したものが演算子全体の結果となります。C 言語のキャスト風に (real) と書くこともできます。

`string 演算子`
:   string 演算子は、右にあるものを評価し、それを文字列型に変換したものが演算子全体の結果となります。C 言語のキャスト風に (string) と書くこともできます。