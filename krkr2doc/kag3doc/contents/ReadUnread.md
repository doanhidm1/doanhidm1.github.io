# 未読/既読処理

未読とはユーザがシナリオをいまだ読んでいないということで、既読とはユーザがすでに読んだということです。
　KAG は、未読の部分と既読の部分でメッセージの表示速度を変えたり、既読の部分では [l] タグを無効にしたりする事ができます。

　未読/既読の記録はシステム変数のうち、`trail_` で始まる変数に記録されます。未読/既読の記録を行うには `Config.tjs` の `autoRecordPageShowing` を true に設定する必要があります。

# 未読部分と既読部分

KAG では、未読部分/既読部分はラベルを目印にして分けられています。
　システム変数の `trail_シナリオファイル名_ラベル` という形式の変数に記録されます。たとえば、first.ks の \*start というラベルであれば、`sf.trail_first_start` という変数名になります。
　この変数が void ( つまり未定義; 数値と比較するときは 0 として見なされます ) ならば 未読で、1 以上であれば既読です。1 以上の場合はその部分を読んだ回数になります。

　基本的に、一つのラベルから次のラベルや [s] タグまでが一つの「部分」として処理されます。
　たとえば、以下のようなシナリオがあるとすると、各色で色分けされたシナリオが各部分ということになります。

|  |
| --- |
| \*部分その1  @cm  ここは部分その1です。[l][r]  普通は次のラベルまでが一つの「部分」となります。[p][r] |
| \*部分その2  @cm  ここは部分その2です。[p][r] |
| \*部分その3  @cm  ここは部分その3です。[l][r]  [[s]タグまでも一つの「部分」となります。[s] |

　この「部分」を単位にして、未読既読が処理されます。

　初期状態ではすべての部分が未読であるとされています。

# 既読判定

これらの「部分」が既読と見なされるには条件があります。原則として、「次のラベルに到達したり [s] タグに到達した」場合にその「部分」が既読であると見なされ、システム変数に記録されます。
　つまり、ユーザが「部分」の途中でプログラムを終了したりして読むのをやめた場合は既読とは見なされない事になります。最後までその「部分」を読まないとなりません。

# シナリオ制御と既読判定

途中にリンクや jump タグなどがあってシナリオが分岐したりする場合はすこし処理が変わります。

リンクの類 ( link や button タグ ) でジャンプする場合
:   これらのタグによってユーザが選択肢などを選択してシナリオの別の部分にジャンプする場合は自動的に既読となります。
    　たとえば以下の例で、

    `*select
    ここの部分は、ユーザが選択肢を選択した時に既読になります。[r]
    [link target=*t1]選択肢1[endlink][r]
    [link target=*t2]選択肢2[endlink][r]
    @wait time=3000
    @jump target=*timeout`

    　選択肢が @wait タグでタイムアウトになる前に選択された場合はその時点で既読という事になります。ちなみに通常の選択肢の使い方では link タグで選択を表示し終わると [s] タグが来ると思うのでその時点で既読になります。
    　link タグや button タグには contpage という属性があって、これを false にすると、その時点でジャンプを行っても既読とはされません。

jump タグ
:   jump タグでジャンプを行う場合もその時点で既読とされます。この場合も coutpage という属性があって、これを false に設定すると既読とはされません。

call と return
:   call タグでサブルーチンを呼ぶときは既読となりません。この場合も coutpage という属性があって、これを true に設定するとその時点で既読とされます。
    　retrun タグはその時点で既読となります ( 呼び出し元が既読になるのではなくて、そのサブルーチンの、return タグのある部分が既読になる )。この場合も coutpage という属性があって、これを false に設定すると既読とはされません。