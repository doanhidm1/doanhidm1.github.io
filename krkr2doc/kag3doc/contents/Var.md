# 変数とは

KAG における変数とは、

・なにかを記憶させておく物

　にすぎません。

　ただし、KAG は、TJS2 というスクリプト言語をベースにしているシステムであり、KAG における変数とは TJS2 の変数そのものですのでかなり強力な機能を発揮します。

　ここはチュートリアルですので、基本的な使い方のみを述べますが、さらに KAG 内部のメソッドやプロパティにアクセスするとか、吉里吉里の機能を直接使うとなると、ほぼ*泥沼*状態なので、はまりやすい性格の方はご注意を(笑)。

# 変数の種類

KAG の変数の種類には 3 つあります。栞のセーブとロードとともにセーブ・ロードされる普通の「ゲーム変数」と、栞のセーブ・ロードとは関係なしに、常に値を保持できる「システム変数」、一時的に値をおいておくための「一時変数」があります。「システム変数」は、吉里吉里/KAG を終了させて、また同じゲームを起動すれば値を保持しています。「一時変数」は吉里吉里を終了させると内容は失われてしまいますし、栞にも値は保存されません。

　ゲーム変数には f という名前が、システム変数には sf という名前が、一時変数には tf という名前が与えられてます。

　また、KAG ( というか TJS2 ) の変数には、文字列でも数値でも入れることができます ( 文字列や数値などの、変数の中に入れるものの種類を「型」といいます )。変数には(ほぼ)自由な名前を付けることができ、変数の数に制限はありませんし、文字列の長さに制限はありません。数値は実数も扱うことができます。
　KAG 3.x からは「配列」と「辞書配列」も扱うことができるようになりました ( ここでは説明しません )。

Note

　TJS2 の整数型は 64bit、実数型は double ( 倍精度 ) の精度を持っています。
　文字列はゼロ終結 UNICODE 文字列を扱い、長さ制限はありません。

# 変数として使用可能な名前

吉里吉里 / KAG では、変数はほぼ自由に名前を付けることができます。しかし、自由といっても吉里吉里 / KAG が使用可能な変数の名前にはルールがあります。

変数名には半角英数と全角文字、\_ (アンダーバー) を使うことができる
:   *`abc&def`* や、*`a-z`* のような変数名は使用できません。
    　*`final_count`* のようにアンダーバーを含んだり、*`主人公の名前`* のように全角文字を使用することができます(全角の記号はすべて使用可能です)。

ただし 変数の名頭に半角の数字が来ることはできない
:   *`2friends`* や *`3com`* のような変数名は使用できません ( 全角の数字が先頭に来るのであれば OK です)。

　これらの変数名の前に、ゲーム変数であれば *`f.`* を、システム変数であれば *`sf.`* を、一時変数であれば *`tf.`* を付けます。
　たとえば、以下のような変数名が考えられます。

 `f.flag1 sf.username sf.playcount tf.i f.enokazu f.変数その１ ...`

　また、初めて使う変数はすべて数値としては 0 で、文字列としては '' ( 空文字列 ) という、すこし特殊な状態にあります。一般的には、変数は最初に値をいれてから使ってください。

Note

*f* や *sf* や *tf* の他に *kag* というのを見かけるかも知れませんが、*kag* は KAG のシステム内部に直接アクセスするときに使われる物です。

# 変数への代入

そうしたら、変数に値を代入するには、通常 eval タグを使います。たとえば、`f.flag1` に 1000 を代入したい場合・・・

`[eval exp="f.flag1 = 1000"]`

　とします。つまり、変数名の後に = を書き、その後に代入したい数値を指定します。

　文字列を代入したい場合は、

`[eval exp="f.変数その１ = '文字列'"]`

　とします。つまり、 = の後に '' でくくった文字列を指定します ( シングルクォーテーションとダブルクォーテーションに注意してください )。
　文字列用の変数や、数値用の変数というように、変数に入れるものの型によって名前が変わると言うことはありません。入れたものの型になります。

　ほかの変数に内容をコピーする場合は、

`[eval exp="f.flag1 = f.flag2"]`

のようにします。

# 変数の演算

計算をしたい場合は、

`[eval exp="f.flag1 = f.flag1 + 1"]`

　等とします。この例では、f.flag1 に 1 を足した物を f.flag1 に代入しています ( つまり f.flag1 に 1 を足している )。
　exp 属性には TJS2 における「式」を書きます。
　式には、\*(乗算) /(除算) +(加算) -(減算) のような普通の演算子は普通に使えます ( 数学の式のように優先順位もあります )。( ) カッコも普通に使えます。
　たとえば、

`[eval exp="f.flag1 = f.flag1 + f.flag2 * f.flag3"]`

　とすると、f.flag2 と f.flag3 をかけたものに f.flag1 が加算されたものが f.flag1 に入ります。

　除算を行うときは / (スラッシュ) を用います。

`[eval exp="f.flag1 = f.flag2 / f.flag3"]`

　この場合は f.flag2 を f.flag3 で割った物が f.flag1 に入ります。
　しかし、割り切れなかった場合は f.flag1 が実数になってしまうので、あまった分を切り捨てて整数の結果を得たい場合は、整数除算演算子 \ を用いて、

`[eval exp="f.flag1 = f.flag2 \ f.flag3"]`

　と記述します。

　あと、文字列同士のつなぎ合わせにも + 演算子を使います。

`[eval exp="f.flag2 = 'hoge'"]
[eval exp="f.flag3 = 'une'"]
[eval exp="f.flag1= f.flag2 + f.flag3"]`

　上記の例では、 f.flag1 には 'hogeune' という文字列が入ります。

Note

　TJS2 の文法は JavaScript (ECMAScript) を参考にして作られたため、これによく似ています ( 完全に同じではありません )。
　通常の算術演算の振る舞いはほぼ同じです。文字列の扱いや文字列と数値の混合演算もほぼ同じです。

# 文字列と数値

KAG の変数は、文字列用の変数、数値用の変数というように変数が分かれることも、名前が変わることもありません。
　文字列を入れればその変数は文字列が、数値をいれればその変数は数値の入った変数になります。
　厄介なのはこれらをまぜて使うときです。+ 演算子にはいろいろな意味とその使い方があります(^^;

　文字列同士のつなぎ合わせには + 演算子、数値の加算にも + 演算子を使いますが、文字列と数値を足そうとしたときは、どちらか一方が文字列ならば、片方の数値は文字列に変換されてつなぎ合わさるというルールがあります。

　たとえば、f.flag2 に 'hoge' という文字列、f.flag3 に 10 という数値が入っていた場合、

`[eval exp="f.flag1 = f.flag2 + f.flag2"]`

　では、f.flag1 には 'hoge10' という文字列が入ります。

　また、どうしても文字列を数値に変換したい場合があると思います。たとえば [input] タグで入力したものを数値として扱いたいときなどですが、この場合にも + 演算子を使います。+ 演算子は、数値にしたい変数の前につけて使います。たとえば、f.flag1 に '20' という文字列が入っていたとして、

`[eval exp="f.flag1 = +f.flag1"]`

　と書けば、f.flag1 の内容は数値に変換され、再び f.flag1 に入ります。f.flag1 は数値の 20 になります。

Note

　+ 演算子が続く場合は注意しなければなりません。f.flag3 を数値にして f.flag2 に加算するなどという式を書く場合、`f.flag2++f.flag3` という書き方ではエラーになります ( ++ という別の演算子があるため )。スペースを空けて `f.flag2+ +f.flag3` と書いてください。

Note

　単項の + 演算子 ( 上記例の `f.flag1 = +f.flag1` のような場合の + ) は、文字列がもし小数表記を含む場合 ( 0.3 とか ) は、結果が実数になります。整数のみを得たい場合は ( 小数点以下を切り捨ててしまいたい場合は )、int + と書けば OK です。たとえば上記例でいけば、`f.flag1 = int +f.flag1` となります。

# 変数の削除・そのほか

変数を削除するには delete を用います。*delete 変数名* でその変数を削除することができます。
　たとえば、`f.flag1` を削除したい場合は、

`[eval exp="delete f.flag1"]`

　とします。

　また、clearvar タグは、ゲーム変数をすべて削除します。

　そのほか、TJS2 で使用可能な演算子や math オブジェクトによる三角関数等の計算 ( そんなの必要かはわかりませんが ) などをすべて使えます。詳しくは吉里吉里 SDK の TJS2 ヘルプを参照してください。

　, (カンマ)を使って複数の式を一つの eval タグ内に書くことができます。
たとえば、

`[eval exp="f.first=true"]
[eval exp="f.flag0=0"]
[eval exp="f.flag1=0"]`

　というような式は、以下のように簡潔に書くことができます。

`[eval exp="f.first=true, f.flag0=0, f.flag1=0"]`

　また、iscript タグを用いると、連続した eval タグを簡潔に書くことができます。

　たとえば、上の式は、

`[iscript]
f.first=true;
f.flag0=0;
f.flag1=0;
[endscript]`

　と書くことができます。各式のあとに ; ( セミコロン ) を忘れないでください。
　このように , (カンマ) や iscript を使うと、使わない場合に比べて非常に高速になります。

# 変数の内容を表示する

変数の内容をシナリオ中に表示したい場合は、emb タグを使います。
　たとえば、以下のようになります。

`[wait time=200]
*start
[cm]
[eval exp="f.数値=200"][eval exp="f.mojiretu='文字列'"]
f.数値 の内容 : [emb exp="f.数値"][l][r]
f.mojiretu の内容 : [emb exp="f.mojiretu"][l][r]`

　実行すると、

f.数値 の内容 : 200
f.mojiretu の内容 : 文字列

　と表示されるはずです。

# エンティティ

エンティティというのは、変数の内容で、他のタグの属性の値を置き換える機能です。
　属性の値に、 & に続けて変数名を書きます。

`[wait time=200]
*start
[cm]
[eval exp="f.fontsize=60"]
[font size="&f.fontsize"]サイズ 60 の文字[resetfont]`

　この場合は、f.fontsize に代入された 60 という数値で、font タグの size 属性の値を置き換えています。

　実際はエンティティは、& の後に書かれた属性の値の内容を、TJS2 式として実行して、その結果で属性の値を置き換える機能です。従って、& の後には TJS2 式を書くことが出来ます。

# 条件の判断

変数がある値と同じであるかを判断するためには以下の演算子を使うことができます。

`a==b    a が b と等しいときに真(true)
a!=b    a が b と等しくない場合に真(true)
a<b     a が b より少ない場合に真(true)
a>b     a が b より大きい場合に真(true)`

　このほか >= や <= (同じかより大きい、同じかより小さい) も使うことができます。
　このような条件判断は主に if タグで使います。

　if タグは、exp で指定した式が 真(true) を示した場合にのみ endif タグまでにある文章やタグを実行します。

`[if exp="f.flag1==2"]f.flag1 は 2 です[endif]
[if exp="f.flag1!=2"]f.flag1 は 2 ではありません[endif]`

　変数は使い方次第で非常に強力な機能となります。